(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[8],{

/***/ "./node_modules/immediate/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/immediate/lib/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/immediate/lib/browser.js?");

/***/ }),

/***/ "./node_modules/pouchdb-wrappers/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/pouchdb-wrappers/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n    Copyright 2014-2015, Marten de Vries\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n\n\nvar nodify = __webpack_require__(/*! promise-nodify */ \"./node_modules/promise-nodify/index.js\");\n\nexports.installStaticWrapperMethods = function (PouchDB, handlers) {\n  //set an 'alternative constructor' so the constructor can be easily\n  //wrapped, since wrapping 'real' constructors is hard.\n  PouchDB.new = PouchDB.new || function (name, options, callback) {\n    return new PouchDB(name, options, callback);\n  };\n  PouchDB.destroy = PouchDB.destroy || function (name, options, callback) {\n    var args = parseBaseArgs(PouchDB, this, options, callback);\n    var db = new PouchDB(name, args.options);\n    var promise = db.destroy();\n    nodify(promise, args.callback);\n    return promise;\n  };\n\n  installWrappers(PouchDB, handlers, exports.createStaticWrapperMethod);\n};\n\nexports.installWrapperMethods = function (db, handlers) {\n  installWrappers(db, handlers, exports.createWrapperMethod);\n};\n\nfunction installWrappers(base, handlers, createWrapperMethod) {\n  for (var name in handlers) {\n    if (!handlers.hasOwnProperty(name)) {\n      continue;\n    }\n    var info = getBaseAndName(base, name);\n    var original = info.base[info.name];\n    if (!original) {\n      //no method to wrap\n      continue;\n    }\n    if (original.hasOwnProperty(\"_handlers\")) {\n      if (original._handlers.indexOf(handlers[name]) !== -1) {\n        throw new Error(\"Wrapper method for '\" + name + \"' already installed: \" + handlers[name]);\n      }\n      original._handlers.push(handlers[name]);\n    } else {\n      info.base[info.name] = createWrapperMethod(name, original, handlers[name], base);\n    }\n  }\n}\n\nfunction getBaseAndName(base, name) {\n  name = name.split(\".\");\n  while (name.length > 1) {\n    base = base[name.shift(0)];\n  }\n  return {\n    base: base,\n    name: name[0]\n  };\n}\n\nexports.createStaticWrapperMethod = function (name, original, handler, PouchDB) {\n  //PouchDB is optional\n  return createWrapper(name, original, handler, staticWrapperBuilders, PouchDB);\n};\n\nexports.createWrapperMethod = function (name, original, handler, db) {\n  //db is optional\n  return createWrapper(name, original, handler, wrapperBuilders, db);\n};\n\nfunction createWrapper(name, original, handler, theWrapperBuilders, thisVal) {\n  //thisVal is optional\n  var buildWrapper = theWrapperBuilders[name];\n  if (typeof buildWrapper === \"undefined\") {\n    throw new Error(\"No known wrapper for method name: \" + name); //coverage: ignore\n  }\n  var handlers = [handler];\n  var wrapper = buildWrapper(thisVal, original, handlers);\n  wrapper._original = original;\n  wrapper._handlers = handlers;\n  return wrapper;\n}\n\nvar wrapperBuilders = {};\n\nwrapperBuilders.destroy = function (db, destroy, handlers) {\n  return function (options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCall(destroy));\n  };\n};\n\nwrapperBuilders.put = function (db, put, handlers) {\n  return function (/*doc, docId, docRev, options, callback*/) {\n    var args = {};\n    args.base = db || this;\n    var argsList = Array.prototype.slice.call(arguments);\n    //parsing code borrowed from PouchDB (adapted).\n    args.doc = argsList.shift();\n    var id = '_id' in args.doc;\n    do {\n      var temp = argsList.shift();\n      var temptype = typeof temp;\n      if (temptype === \"string\" && !id) {\n        args.doc._id = temp;\n        id = true;\n      } else if (temptype === \"string\" && id && !('_rev' in args.doc)) {\n        args.doc._rev = temp;\n      } else if (temptype === \"object\") {\n        args.options = temp;\n      } else if (temptype === \"function\") {\n        args.callback = temp;\n      }\n    } while (argsList.length);\n    args.options = args.options || {};\n    return callHandlers(handlers, args, function () {\n      return put.call(this, args.doc, args.options);\n    });\n  };\n};\n\nwrapperBuilders.post = function (db, post, handlers) {\n  return function (doc, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.doc = doc;\n    return callHandlers(handlers, args, function () {\n      return post.call(this, args.doc, args.options);\n    });\n  };\n};\n\nwrapperBuilders.get = function (db, get, handlers) {\n  return function (docId, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.docId = docId;\n    return callHandlers(handlers, args, function () {\n      return get.call(this, args.docId, args.options);\n    });\n  };\n};\n\nwrapperBuilders.remove = function (db, remove, handlers) {\n  return function (docOrId, optsOrRev, opts, callback) {\n    var args;\n\n    //originally borrowed from PouchDB\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      args = parseBaseArgs(db, this, opts, callback);\n      args.doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n    } else {\n      // doc, opts, callback style\n      args = parseBaseArgs(db, this, optsOrRev, opts);\n      args.doc = docOrId;\n    }\n\n    return callHandlers(handlers, args, function () {\n      return remove.call(this, args.doc, args.options);\n    });\n  };\n};\n\nwrapperBuilders.bulkDocs = function (db, bulkDocs, handlers) {\n  return function (docs, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    //support the deprecated signature.\n    if (typeof(docs) === 'object' && 'new_edits' in docs) {\n      args.options.new_edits = docs.new_edits;\n    }\n    args.docs = docs.docs || docs;\n    return callHandlers(handlers, args, function () {\n      return bulkDocs.call(this, args.docs, args.options);\n    });\n  };\n};\n\nwrapperBuilders.allDocs = function (db, allDocs, handlers) {\n  return function (options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCallWithOptions(allDocs, args));\n  };\n};\nwrapperBuilders.bulkGet = wrapperBuilders.allDocs;\n\nwrapperBuilders.changes = function (db, changes, handlers) {\n  return function (options, callback) {\n    //the callback argument is no longer documented. (And deprecated?)\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCallWithOptions(changes, args));\n  };\n};\n\nwrapperBuilders.sync = function (db, replicate, handlers) {\n  return function (url, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.url = url;\n    return callHandlers(handlers, args, function () {\n      return replicate.call(this, args.url, args.options);\n    });\n  };\n};\n\nwrapperBuilders[\"replicate.from\"] = wrapperBuilders.sync;\nwrapperBuilders[\"replicate.to\"] = wrapperBuilders.sync;\n\nwrapperBuilders.putAttachment = function (db, putAttachment, handlers) {\n  return function (docId, attachmentId, rev, doc, type, options, callback) {\n    //options is not an 'official' argument. But some plug-ins need it\n    //and maybe (?) also the http adapter.\n\n    //valid calls:\n    //- \"id\", \"aid\", \"rev\", new Blob(), \"text/plain\", {}, function () {}\n    //- \"id\", \"aid\", new Blob(), \"text/plain\", {}, function () {}\n    //- \"id\", \"aid\", new Blob(), \"text/plain\"\n    var args;\n    if (typeof type === \"string\") {\n      //rev is specified\n      args = parseBaseArgs(db, this, options, callback);\n      args.rev = rev;\n      args.doc = doc;\n      args.type = type;\n    } else {\n      //rev is unspecified\n      args = parseBaseArgs(db, this, type, options);\n      args.rev = null;\n      args.doc = rev;\n      args.type = doc;\n    }\n    //fixed arguments\n    args.docId = docId;\n    args.attachmentId = attachmentId;\n\n    return callHandlers(handlers, args, function () {\n      return putAttachment.call(this, args.docId, args.attachmentId, args.rev, args.doc, args.type);\n    });\n  };\n};\n\nwrapperBuilders.getAttachment = function (db, getAttachment, handlers) {\n  return function (docId, attachmentId, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.docId = docId;\n    args.attachmentId = attachmentId;\n    return callHandlers(handlers, args, function () {\n      return getAttachment.call(this, args.docId, args.attachmentId, args.options);\n    });\n  };\n};\n\nwrapperBuilders.removeAttachment = function (db, removeAttachment, handlers) {\n  return function (docId, attachmentId, rev, options, callback) {\n    //see note on the options argument at putAttachment.\n    var args = parseBaseArgs(db, this, options, callback);\n    args.docId = docId;\n    args.attachmentId = attachmentId;\n    args.rev = rev;\n    return callHandlers(handlers, args, function () {\n      return removeAttachment.call(this, args.docId, args.attachmentId, args.rev);\n    });\n  };\n};\n\nwrapperBuilders.query = function (db, query, handlers) {\n  return function (fun, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.fun = fun;\n    return callHandlers(handlers, args, function () {\n      return query.call(this, args.fun, args.options);\n    });\n  };\n};\n\nwrapperBuilders.viewCleanup = function (db, viewCleanup, handlers) {\n  return function (options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCallWithOptions(viewCleanup, args));\n  };\n};\n\nwrapperBuilders.createIndex = function (db, createIndex, handlers) {\n  return function (index, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.index = index;\n    return callHandlers(handlers, args, function () {\n      return createIndex.call(this, args.index);\n    });\n  };\n};\nwrapperBuilders.deleteIndex = wrapperBuilders.createIndex;\n\n\nwrapperBuilders.find = function (db, find, handlers) {\n  return function (request, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.request = request;\n    return callHandlers(handlers, args, function () {\n      return find.call(this, args.request);\n    });\n  };\n};\nwrapperBuilders.explain = wrapperBuilders.find;\n\nwrapperBuilders.info = function (db, info, handlers) {\n  return function (options, callback) {\n    //see note on the options argument at putAttachment.\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCall(info));\n  };\n};\nwrapperBuilders.getIndexes = wrapperBuilders.info;\n\nwrapperBuilders.compact = function (db, compact, handlers) {\n  return function (options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCallWithOptions(compact, args));\n  };\n};\n\nwrapperBuilders.revsDiff = function (db, revsDiff, handlers) {\n  return function (diff, options, callback) {\n    //see note on the options argument at putAttachment.\n    var args = parseBaseArgs(db, this, options, callback);\n    args.diff = diff;\n    return callHandlers(handlers, args, function () {\n      return revsDiff.call(this, args.diff);\n    });\n  };\n};\n\n//Plug-in wrapperBuilders; only of the plug-ins for which a wrapper\n//has been necessary.\n\nwrapperBuilders.list = function (db, orig, handlers) {\n  return function (path, options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    args.path = path;\n\n    return callHandlers(handlers, args, function () {\n      return orig.call(this, args.path, args.options);\n    });\n  };\n};\n\nwrapperBuilders.rewriteResultRequestObject = wrapperBuilders.list;\nwrapperBuilders.show = wrapperBuilders.list;\nwrapperBuilders.update = wrapperBuilders.list;\n\nwrapperBuilders.getSecurity = function (db, getSecurity, handlers) {\n  return function (options, callback) {\n    var args = parseBaseArgs(db, this, options, callback);\n    return callHandlers(handlers, args, makeCallWithOptions(getSecurity, args));\n  };\n};\n\nwrapperBuilders.putSecurity = function (db, putSecurity, handlers) {\n  return function (secObj, options, callback) {\n    //see note on the options argument at putAttachment.\n    var args = parseBaseArgs(db, this, options, callback);\n    args.secObj = secObj;\n    return callHandlers(handlers, args, function () {\n      return putSecurity.call(this, args.secObj);\n    });\n  };\n};\n\n//static\nvar staticWrapperBuilders = {};\n\nstaticWrapperBuilders.new = function (PouchDB, construct, handlers) {\n  return function (name, options, callback) {\n    var args;\n    if (typeof name === \"object\") {\n      args = parseBaseArgs(PouchDB, this, name, options);\n    } else {\n      args = parseBaseArgs(PouchDB, this, options, callback);\n      args.options.name = name;\n    }\n    return callHandlers(handlers, args, function () {\n      return construct.call(this, args.options);\n    });\n  };\n};\n\nstaticWrapperBuilders.destroy = function (PouchDB, destroy, handlers) {\n  return function (name, options, callback) {\n    var args;\n    if (typeof name === \"object\") {\n      args = parseBaseArgs(PouchDB, this, name, options);\n    } else {\n      args = parseBaseArgs(PouchDB, this, options, callback);\n      args.options.name = name;\n    }\n    if (args.options.internal) {\n      return destroy.apply(PouchDB, arguments);\n    }\n    return callHandlers(handlers, args, function () {\n      var name = args.options.name;\n      delete args.options.name;\n\n      return destroy.call(this, name, args.options);\n    });\n  };\n};\n\nstaticWrapperBuilders.replicate = function (PouchDB, replicate, handlers) {\n  return function (source, target, options, callback) {\n    //no callback\n    var args = parseBaseArgs(PouchDB, this, options, callback);\n    args.source = source;\n    args.target = target;\n    return callHandlers(handlers, args, function () {\n      return replicate.call(this, args.source, args.target, args.options);\n    });\n  };\n};\n\nstaticWrapperBuilders.allDbs = function (PouchDB, allDbs, handlers) {\n  return function (options, callback) {\n    var args = parseBaseArgs(PouchDB, this, options, callback);\n    return callHandlers(handlers, args, makeCall(allDbs));\n  };\n};\n\n//Wrap .plugin()? .on()? .defaults()? No use case yet, but it's\n//possible...\n\nfunction parseBaseArgs(thisVal1, thisVal2, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  return {\n    base: thisVal1 || thisVal2,\n    options: options || {},\n    callback: callback\n  };\n}\n\nfunction callHandlers(handlers, args, method) {\n  var callback = args.callback;\n  delete args.callback;\n\n  //build a chain of handlers: the bottom handler calls the 'real'\n  //method, the other handlers call other handlers.\n  method = method.bind(args.base);\n  for (var i = handlers.length - 1; i >= 0; i -= 1) {\n    method = handlers[i].bind(null, method, args);\n  }\n  //start running the chain.\n  var promise = method();\n  nodify(promise, callback);\n  return promise;\n}\n\nfunction makeCall(func) {\n  return function () {\n    return func.call(this);\n  };\n}\n\nfunction makeCallWithOptions(func, args) {\n  return function () {\n    return func.call(this, args.options);\n  };\n}\n\nexports.uninstallWrapperMethods = function (db, handlers) {\n  uninstallWrappers(db, handlers);\n};\n\nexports.uninstallStaticWrapperMethods = function (PouchDB, handlers) {\n  uninstallWrappers(PouchDB, handlers);\n};\n\nfunction uninstallWrappers(base, handlers) {\n  for (var name in handlers) {\n    if (!handlers.hasOwnProperty(name)) {\n      continue;\n    }\n    var info = getBaseAndName(base, name);\n    var wrapper = info.base[info.name];\n    if (typeof wrapper === \"undefined\") {\n      //method doesn't exist, so was never wrapped in the first place.\n      continue;\n    }\n\n    var idx;\n    try {\n      idx = wrapper._handlers.indexOf(handlers[name]);\n    } catch (err) {\n      idx = -1;\n    }\n    if (idx === -1) {\n      throw new Error(\"Wrapper method for '\" + name + \"' not installed: \" + handlers[name]);\n    }\n    wrapper._handlers.splice(idx, 1);\n    if (!wrapper._handlers.length) {\n      //fall back to the original on the prototype.\n      delete info.base[info.name];\n      if (info.base[info.name] !== wrapper._original) {\n        //nothing or something unexpected was on the prototype. (E.g.\n        //replicate.to). Reset the original manually.\n        info.base[info.name] = wrapper._original;\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/pouchdb-wrappers/lib/index.js?");

/***/ }),

/***/ "./node_modules/transform-pouch/index.js":
/*!***********************************************!*\
  !*** ./node_modules/transform-pouch/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar Promise = __webpack_require__(/*! lie */ \"./node_modules/lie/lib/index.js\");\nvar utils = __webpack_require__(/*! ./pouch-utils */ \"./node_modules/transform-pouch/pouch-utils.js\");\nvar wrappers = __webpack_require__(/*! pouchdb-wrappers */ \"./node_modules/pouchdb-wrappers/lib/index.js\");\nvar immediate = __webpack_require__(/*! immediate */ \"./node_modules/immediate/lib/browser.js\");\n\nfunction isntInternalKey(key) {\n  return key[0] !== '_';\n}\n\nfunction isUntransformable(doc) {\n  var isLocal = typeof doc._id === 'string' && utils.isLocalId(doc._id);\n\n  if (isLocal) {\n    return true;\n  }\n\n  if (doc._deleted) {\n    return Object.keys(doc).filter(isntInternalKey).length === 0;\n  }\n\n  return false;\n}\n\n// api.filter provided for backwards compat with the old \"filter-pouch\"\nexports.transform = exports.filter = function transform(config) {\n  var db = this;\n\n  var incoming = function (doc) {\n    if (!isUntransformable(doc) && config.incoming) {\n      return config.incoming(utils.clone(doc));\n    }\n    return doc;\n  };\n  var outgoing = function (doc) {\n    if (!isUntransformable(doc) && config.outgoing) {\n      return config.outgoing(utils.clone(doc));\n    }\n    return doc;\n  };\n\n  var handlers = {};\n\n  if (db.type() === 'http') {\n    handlers.query = function (orig) {\n      var none = {};\n      return orig().then(function (res) {\n        return utils.Promise.all(res.rows.map(function (row) {\n          if (row.doc) {\n            return outgoing(row.doc);\n          }\n          return none;\n        })).then(function (resp) {\n          resp.forEach(function (doc, i) {\n            if (doc === none) {\n              return;\n            }\n            res.rows[i].doc = doc;\n          });\n          return res;\n        });\n      });\n    };\n  }\n\n  handlers.get = function (orig) {\n    return orig().then(function (res) {\n      if (Array.isArray(res)) {\n        var none = {};\n        // open_revs style, it's a list of docs\n        return utils.Promise.all(res.map(function (row) {\n          if (row.ok) {\n            return outgoing(row.ok);\n          }\n          return none;\n        })).then(function (resp) {\n          resp.forEach(function (doc, i) {\n            if (doc === none) {\n              return;\n            }\n            res[i].ok = doc;\n          });\n          return res;\n        });\n      } else {\n        return outgoing(res);\n      }\n    });\n  };\n\n  handlers.bulkDocs = function (orig, args) {\n    for (var i = 0; i < args.docs.length; i++) {\n      args.docs[i] = incoming(args.docs[i]);\n    }\n    return Promise.all(args.docs).then(function (docs) {\n      args.docs = docs;\n      return orig();\n    });\n  };\n\n  handlers.allDocs = function (orig) {\n    return orig().then(function (res) {\n      var none = {};\n      return utils.Promise.all(res.rows.map(function (row) {\n        if (row.doc) {\n          return outgoing(row.doc);\n        }\n        return none;\n      })).then(function (resp) {\n        resp.forEach(function (doc, i) {\n          if (doc === none) {\n            return;\n          }\n          res.rows[i].doc = doc;\n        });\n        return res;\n      });\n    });\n  };\n\n  handlers.bulkGet = function (orig) {\n    return orig().then(function (res) {\n      var none = {};\n      return utils.Promise.all(res.results.map(function (result) {\n        if (result.id && result.docs && Array.isArray(result.docs)) {\n          return {\n            docs: result.docs.map(function(doc) {\n              if (doc.ok) {\n                return {ok: outgoing(doc.ok)};\n              } else {\n                return doc;\n              }\n            }),\n            id: result.id\n          };\n        } else {\n          return none;\n        }\n      })).then(function (results) {\n        return {results: results};\n      });\n    });\n  };\n  \n  handlers.changes = function (orig) {\n    function modifyChange(change) {\n      if (change.doc) {\n        return utils.Promise.resolve(outgoing(change.doc)).then(function (doc) {\n          change.doc = doc;\n          return change;\n        });\n      }\n      return utils.Promise.resolve(change);\n    }\n\n    function modifyChanges(res) {\n      if (res.results) {\n        return utils.Promise.all(res.results.map(modifyChange)).then(function (results) {\n          res.results = results;\n          return res;\n        });\n      }\n      return utils.Promise.resolve(res);\n    }\n\n    var changes = orig();\n    // override some events\n    var origOn = changes.on;\n    changes.on = function (event, listener) {\n      if (event === 'change') {\n        return origOn.apply(changes, [event, function (change) {\n          modifyChange(change).then(function (resp) {\n            immediate(function () {\n              listener(resp);\n            });\n          });\n        }]);\n      } else if (event === 'complete') {\n        return origOn.apply(changes, [event, function (res) {\n          modifyChanges(res).then(function (resp) {\n            process.nextTick(function () {\n              listener(resp);\n            });\n          });\n        }]);\n      }\n      return origOn.apply(changes, [event, listener]);\n    };\n\n    var origThen = changes.then;\n    changes.then = function (resolve, reject) {\n      return origThen.apply(changes, [function (res) {\n        return modifyChanges(res).then(resolve, reject);\n      }, reject]);\n    };\n    return changes;\n  };\n  wrappers.installWrapperMethods(db, handlers);\n};\n\n/* istanbul ignore next */\nif (typeof window !== 'undefined' && window.PouchDB) {\n  window.PouchDB.plugin(exports);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/transform-pouch/index.js?");

/***/ }),

/***/ "./node_modules/transform-pouch/node_modules/inherits/inherits_browser.js":
/*!********************************************************************************!*\
  !*** ./node_modules/transform-pouch/node_modules/inherits/inherits_browser.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/transform-pouch/node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/transform-pouch/node_modules/pouchdb-promise/lib/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/transform-pouch/node_modules/pouchdb-promise/lib/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar lie = _interopDefault(__webpack_require__(/*! lie */ \"./node_modules/lie/lib/index.js\"));\n\n/* istanbul ignore next */\nvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\nmodule.exports = PouchPromise;\n\n//# sourceURL=webpack:///./node_modules/transform-pouch/node_modules/pouchdb-promise/lib/index.js?");

/***/ }),

/***/ "./node_modules/transform-pouch/pouch-utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/transform-pouch/pouch-utils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar Promise = __webpack_require__(/*! pouchdb-promise */ \"./node_modules/transform-pouch/node_modules/pouchdb-promise/lib/index.js\");\n/* istanbul ignore next */\nexports.once = function (fun) {\n  var called = false;\n  return exports.getArguments(function (args) {\n    if (called) {\n      console.trace();\n      throw new Error('once called  more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n};\n/* istanbul ignore next */\nexports.getArguments = function (fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n    return fun.call(this, args);\n  };\n};\n/* istanbul ignore next */\nexports.toPromise = function (func) {\n  //create the function we will be returning\n  return exports.getArguments(function (args) {\n    var self = this;\n    var tempCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    // if the last argument is a function, assume its a callback\n    var usedCB;\n    if (tempCB) {\n      // if it was a callback, create a new callback which calls it,\n      // but do so async so we don't trap any errors\n      usedCB = function (err, resp) {\n        process.nextTick(function () {\n          tempCB(err, resp);\n        });\n      };\n    }\n    var promise = new Promise(function (fulfill, reject) {\n      try {\n        var callback = exports.once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        func.apply(self, args);\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    promise.cancel = function () {\n      return this;\n    };\n    return promise;\n  });\n};\n\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/transform-pouch/node_modules/inherits/inherits_browser.js\");\nexports.Promise = Promise;\nexports.extend = __webpack_require__(/*! pouchdb-extend */ \"./node_modules/pouchdb-extend/index.js\");\nexports.clone = function (obj) {\n  return exports.extend(true, {}, obj);\n};\n\nexports.isLocalId = function (id) {\n  return (/^_local/).test(id);\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/transform-pouch/pouch-utils.js?");

/***/ })

}]);